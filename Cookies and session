
A cookie is a small piece of data stored by the browser on the user's machine. It is sent along with every request to the same domain.


.> 
What is a Cookie?
A cookie is a small piece of data stored by the browser on the user's machine. It is sent along with every request to the same domain.



Why Cookies Are Used
Session management (like login/logout)

Storing user preferences (like dark mode)

Tracking (analytics, ads)


What Makes a Cookie Secure?
HttpOnly: Cannot be accessed via JavaScript (document.cookie). Helps prevent XSS attacks.

Secure: Only sent over HTTPS.

SameSite: Controls cross-site cookie sharing (Strict, Lax, or None).

Short expiry time or token rotation.

Signed cookies: Prevent tampering by the client.




npm install express cookie-parser mongoose dotenv

app.js file :
===================== >
require("dotenv").config();
const express = require("express");
const mongoose = require("mongoose");
const cookieParser = require("cookie-parser");

const app = express();
const User = require("./models/User");

app.use(express.json());
app.use(cookieParser(process.env.SECRET_KEY)); // for signed cookies

mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("MongoDB connected"))
  .catch(err => console.error(err));

// ðŸ§ª Login route (sets a cookie)
app.post("/login", async (req, res) => {
  const { username, password } = req.body;

  // Normally you'd validate and hash password
  const user = await User.findOne({ username, password });
  if (!user) return res.status(401).json({ message: "Invalid credentials" });

  res.cookie("session_id", user._id.toString(), {
    httpOnly: true, // JavaScript can't access this
    secure: true,   // Only sent over HTTPS
    sameSite: "Strict", // Only sent to same-site requests
    signed: true,   // Prevent tampering
    maxAge: 1000 * 60 * 60 * 2 // 2 hours
  });

  res.json({ message: "Login successful" });
});

// âœ… Access cookie-protected route
app.get("/dashboard", (req, res) => {
  const sessionId = req.signedCookies.session_id;

  if (!sessionId) return res.status(401).json({ message: "Not logged in" });

  res.json({ message: "Welcome to dashboard", userId: sessionId });
});

// ðŸ§¹ Logout (clear cookie)
app.post("/logout", (req, res) => {
  res.clearCookie("session_id");
  res.json({ message: "Logged out" });
});

app.listen(process.env.PORT, () => {
  console.log(`Server running on port ${process.env.PORT}`);
});



============================================================== >

Common Cookie Methods in Express
When using the cookie-parser middleware, Express gives you these useful methods:

âž¤ res.cookie(name, value, [options])
Used to set a cookie.

âž¤ req.cookies
Returns all cookies sent by the client (not signed).

âž¤ req.signedCookies
Returns all signed cookies (if cookie-parser is used with a secret).

âž¤ res.clearCookie(name)
Used to delete a cookie by clearing it from the browser.


 3. Cookie Options (Fields You Can Use)
These are the most commonly used fields/options when setting cookies:

Option	Type	Description
maxAge	Number	Time in ms (e.g., 1000 * 60 * 60 for 1 hour) after which the cookie expires.
expires	Date	Exact date/time when cookie expires.
httpOnly	Boolean	If true, cookie is not accessible via JavaScript (helps prevent XSS attacks).
secure	Boolean	If true, cookie is only sent over HTTPS (helps prevent MITM attacks).
signed	Boolean	If true, the cookie will be signed to prevent tampering.
sameSite	String	Controls cross-site cookie sending. Values: 'Strict', 'Lax', 'None'.
domain	String	Cookie only sent to this domain.
path	String	Cookie only sent to this path. Default is '/'.
priority	String	'low', 'medium', 'high' (not widely used, helps browser decide what to keep).




ex:

With Expiry Date :

.> res.cookie('token', 'jwt123', { expires: new Date(Date.now() + 86400000) }); // 1 day

------------------------------------------------------------------------->
Secure Cookie :

.> res.cookie('secureCookie', 'value', { secure: true });

------------------------------------------------------------------------->

HttpOnly Cookie (not accessible via document.cookie) :

.> res.cookie('authToken', 'secret', { httpOnly: true });

------------------------------------------------------------------------->
Signed Cookie

.> res.cookie('userId', '123', { signed: true });



res.cookie("fullExample", "myValue", {
  maxAge: 1000 * 60 * 10,   // 10 minutes
  httpOnly: true,
  secure: true,
  signed: true,
  sameSite: "Strict",
  path: "/",
  domain: "localhost"
});


In logging route :
-======================== >
app.post("/login", (req, res) => {
  const { username } = req.body;

  // Simulating login
  res.cookie("session_id", "123456789", {
    maxAge: 3600000,     // 1 hour
    httpOnly: true,
    secure: true,
    signed: true,
    sameSite: "Lax"
  });

  res.send("Logged in!");
});

 Logout Example in logout route :
========================================== >

app.post("/logout", (req, res) => {
  res.clearCookie("session_id");
  res.send("Logged out!");
});


Cookie vs JWT in Header: What's the Real Deal?
============================================================> 

You can send a JWT token (or any auth token) in two ways:

Via HTTP Header (usually in Authorization header)

Via HTTP Cookie (res.cookie)

Both methods work, but cookies have some key advantages, especially in terms of security, browser behavior, and ease of use.



 Advantages of Using Cookies Over Headers for JWT ?
============================================================= >

Letâ€™s get into the deep and rarely known differences, point by point.

âœ… 1. Automatic Handling by the Browser
Cookie: Automatically included with every request to the same domain (no need to manually send the token).

Header: You must manually add the Authorization header in frontend code for every request.


2. HttpOnly Cookies Prevent XSS Attacks
Cookie: With httpOnly: true, the cookie is invisible to JavaScript. This means no attacker can steal it using document.cookie.

Header: JWTs stored in localStorage or sessionStorage can be accessed by malicious JavaScript.

ðŸ›¡ï¸ This is a HUGE security win for cookies.

3. SameSite Protection (CSRF Defense)
Cookies can use SameSite: 'Strict' or 'Lax' to prevent CSRF (cross-site request forgery).

JWT in headers needs a separate CSRF token mechanism for protection.

ðŸ” Cookies have built-in CSRF protection, JWT in headers needs extra work.


4. Better for Browser Auth (Sessions) :

If you're building a web app, cookies behave like traditional sessions, so they work well with server-side rendering (SSR) and frameworks like Next.js, Nuxt, etc.

JWT headers are more suited for API-based mobile apps or SPAs.

ðŸ’¡ So: for web apps, cookies feel more natural.


5. Can Be Encrypted + Signed (Double Protection) :

Cookies can be signed (so they canâ€™t be tampered with) and even encrypted if needed.

JWTs are just base64-encoded, so anyone can decode the payload. You need to validate the signature separately.

ðŸ‘€ Cookies can have layered security: httpOnly + signed + encrypted.


6. No Risk of LocalStorage Leaks :

Storing JWTs in localStorage means:

.>The token remains even after logout unless you manually delete it.
.> Exposed to XSS

Cookies:
=========== >
.> Can be auto-expired with maxAge
.> Cannot be read/modified with JavaScript if httpOnly is set


7. Easier Logout Mechanism
Cookies can be cleared on logout with just:

.> res.clearCookie("token");

.> JWT in header: Must be removed manually from localStorage, sessionStorage, and/or Redux state.


Rare & Advanced Insights (Less Known)
âš ï¸ 1. JWTs in headers can still be used in CSRF attacks
Because Authorization headers arenâ€™t protected by SameSite, malicious scripts can send them if CORS isn't configured properly.

â†’ Cookies allow SameSite defense by default.

ðŸ§  2. Cookie Expiry is Managed by the Server
You set cookie expiry with maxAge or expires, and the browser follows it.

With header JWT:

You must decode it and check the expiry manually on the client or server.

ðŸ”„ 3. JWT Rotation is Easier with Cookies
You can store access token in cookie and refresh token in another cookie

This way you get auto-rotation + CSRF protection

For header JWT: refresh token logic is complex and prone to vulnerabilities if not done properly.

ðŸš« 4. Secure Cookies Can't Be Sent Over HTTP
If you set:

js
Copy code
secure: true
That cookie wonâ€™t be sent over HTTP. Thatâ€™s an extra layer of security.

JWT in headers has no such auto-block.





Auth Middleware (middleware/auth.js)

const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
  const token = req.cookies.token;
  if (!token) return res.status(401).json({ message: "No token, authorization denied" });

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded.user;
    next();
  } catch (err) {
    res.status(401).json({ message: "Token is not valid" });
  }
};

Routes (routes/auth.js)
=========================== >

const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const auth = require('../middleware/auth');
const router = express.Router();

// Register
router.post("/register", async (req, res) => {
  const { name, email, password } = req.body;
  try {
    let user = await User.findOne({ email });
    if (user) return res.status(400).json({ message: "User already exists" });

    user = new User({ name, email, password });
    user.password = await bcrypt.hash(password, 10);
    await user.save();

    res.status(201).json({ message: "User registered successfully" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Login
router.post("/login", async (req, res) => {
  const { email, password } = req.body;
  try {
    const user = await User.findOne({ email });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) return res.status(400).json({ message: "Invalid credentials" });

    const payload = { user: { id: user.id } };
    const token = jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: process.env.JWT_EXPIRES_IN });

    res.cookie("token", token, {
      httpOnly: true,
      secure: false, // set to true in production with HTTPS
      sameSite: "Strict",
      maxAge: 24 * 60 * 60 * 1000 // 1 day
    });

    res.json({ message: "Login successful" });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
});

// Protected Route
router.get("/dashboard", auth, async (req, res) => {
  res.json({ message: "Welcome to the dashboard", userId: req.user.id });
});

// Logout
router.get("/logout", (req, res) => {
  res.clearCookie("token");
  res.json({ message: "Logged out successfully" });
});

module.exports = router;

app.js :
===============>

require('dotenv').config();
const express = require('express');
const connectDB = require('./config/db');
const cookieParser = require('cookie-parser');

const app = express();
connectDB();

app.use(express.json());
app.use(cookieParser());

app.use("/api", require('./routes/auth'));

app.listen(process.env.PORT, () => console.log(`Server running on port ${process.env.PORT}`));


What is a Cookie?
A cookie is a small piece of data stored on the user's browser. It's usually used for:

Session tracking

Authentication

Remembering user preferences

Analytics and more

ðŸ« What is a Signed Cookie?
A signed cookie is a cookie with a digital signature to verify that it hasnâ€™t been tampered with on the client side.

ðŸ” Definition:
A signed cookie in Express is a cookie that has been cryptographically signed using a secret key, so even if someone tries to change its value manually in the browser, Express will detect it and reject it.

âš–ï¸ Difference: Normal Cookie vs Signed Cookie
Feature	ðŸª Normal Cookie	ðŸ” Signed Cookie
Value Tampering Detection	âŒ Cannot detect tampering	âœ… Can detect tampering with signature validation
Cryptographic Signature	âŒ No	âœ… Yes (HMAC with secret key)
Secure?	âŒ Less secure	âœ… More secure
Use case	General data, theme, token	Sensitive data like session IDs or flags
Express access key	req.cookies	req.signedCookies
Set using	res.cookie("key", "value")	res.cookie("key", "value", { signed: true })



How Express Signs a Cookie
When you sign a cookie, Express appends a hash of the cookieâ€™s value and the server's secret key. It looks like this:

txt
Copy code
value.signature
Then when the cookie comes back in a request, Express recalculates the signature and compares it. If it's mismatched (i.e., user tampered), the cookie is rejected.

Enabling Signed Cookies in Express
ðŸ”¹ Step 1: Initialize cookie-parser with a secret

const cookieParser = require('cookie-parser');
app.use(cookieParser('mySecretKey')); // Signing key

const express = require('express');
const cookieParser = require('cookie-parser');

const app = express();
app.use(cookieParser('supersecret123')); // secret key

// Set a signed cookie
app.get('/set', (req, res) => {
  res.cookie('userId', '12345', { signed: true, httpOnly: true });
  res.send('Signed cookie set');
});

// Get signed cookie
app.get('/get', (req, res) => {
  const userId = req.signedCookies.userId;
  if (userId) {
    res.send(`Signed Cookie Value: ${userId}`);
  } else {
    res.send('Signed cookie not found or tampered');
  }
});

// Clear the cookie
app.get('/clear', (req, res) => {
  res.clearCookie('userId');
  res.send('Cookie cleared');
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});

What Happens if Someone Modifies a Signed Cookie?
Letâ€™s say your browser has this cookie:


userId=12345.abcdEFGH1234567Signature

.> If someone changes the value in dev tools to userId=67890.abcdEFGH1234567Signature, the signature will not match the new value, and Express will throw the cookie away when checking req.signedCookies.


Why Not Use Signed Cookies for Everything?
ðŸ”¸ You shouldnâ€™t store large or sensitive data (like JWTs, passwords) in signed cookies because:

Cookies are limited in size (~4 KB)

Use secure HTTP-only JWT tokens or session stores for high-security needs

ðŸ”¸ Signed cookies are useful for:

Protecting small flags (e.g. user roles)

Preventing basic tampering

Middleware validation




Combine Signed + Secure + HTTPOnly
============================================== >
res.cookie("flag", "admin", {
  signed: true,
  httpOnly: true,
  secure: true,        // only over HTTPS
  sameSite: "Strict"
});


res.cookie(name, value, options) Structure
Parameter	Meaning
"flag"	Name of the cookie
"admin"	Value of the cookie
{...}	Options like signed, httpOnly, etc.
ðŸ” Explanation of "flag" and "admin"
âœ… "flag" â€“ Cookie Name
This is the key or identifier for the cookie. It's what you'll use to access it later.

When the browser sends cookies back to the server, it does so like this:

makefile
Copy code
Cookie: flag=admin
You can set any name you want here, for example:

token

sessionId

userType

theme

flag â† (just a name you chose)

So flag is just a label. You could name it anything.

âœ… "admin" â€“ Cookie Value
This is the actual value stored under the name "flag".

In this case, itâ€™s storing the string "admin" â€” this could represent a user role like:

"admin" â€“ Admin user

"user" â€“ Regular user

"guest" â€“ Guest user

So later, you can read this cookie to determine user permissions:

js
Copy code
const role = req.signedCookies.flag;

if (role === "admin") {
  // show admin dashboard
} else {
  // show normal dashboard
}
ðŸ’¡ Custom Example
You could also set it like this:

js
Copy code
res.cookie("role", "superuser", { signed: true });
Then access it using:

js
Copy code
req.signedCookies.role  // returns "superuser"
ðŸ“Œ Final Summary
Part	What It Is	In Example
"flag"	Name of the cookie (key)	The key stored in the browser
"admin"	Value of the cookie	User role or identifier
{...}	Settings like signed, httpOnly, etc.	Adds security features



const token = jwt.sign(
  { userId: user._id, name: user.name, role: user.role },
  'mySecretKey',
  { expiresIn: '1h' }
);

// Set it in a cookie instead of sending as JSON
res.cookie("token", token, {
  httpOnly: true,
  secure: true,      // Only sent over HTTPS (in production)
  sameSite: "strict", // CSRF protection
  maxAge: 60 * 60 * 1000 // 1 hour
});







 Client Makes Request (Browser or Postman) :
========================================================= >

Whenever the browser (or Postman with cookies enabled) makes a request:

http
Copy code
GET /dashboard
Cookie: token=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...

.> The cookie is automatically sent with each request. You donâ€™t need to add Authorization headers manually.

in the auth middlware :

const jwt = require('jsonwebtoken');

function authMiddleware(req, res, next) {
  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ message: "No token, auth denied" });
  }

  try {
    const decoded = jwt.verify(token, 'mySecretKey');
    req.user = decoded; // Put user info in request object
    next();
  } catch (err) {
    return res.status(403).json({ message: "Invalid or expired token" });
  }
}


npm install cookie-parser

const cookieParser = require('cookie-parser');
app.use(cookieParser());

. Postman Stores the Cookie Automatically
Postman saves this cookie in its internal cookie jar.

You can view it:

Click on the "Cookies" button near the "Send" button.

Select your domain (e.g., localhost).

Youâ€™ll see a cookie with:

Name: token

Value: (your JWT)

Expires: (based on maxAge)

HTTP Only: true

âœ… You donâ€™t need to add anything manually in headers!


================================================================= >

Login â†’ A cookie (like authToken) is sent in the response and stored by Postman.

Logout â†’ If your server does not explicitly clear/delete the cookie, it stays in Postman (or browser) until it expires or you manually remove it.


postman stores cookies until manually cleared or expired.

Even after logout, if the cookie is not cleared from server, Postman wonâ€™t remove it automatically.

Thatâ€™s why you still see it in the "Cookies" tab.

NOTE: When using res.clearCookie(), you must provide the same options (path, httpOnly, secure, etc.) that were used when setting the cookie, otherwise the cookie may not be cleared properly.


const cookieOptions = {
  httpOnly: true,
  secure: true, // Use false in development if not using HTTPS
  path: '/',
  maxAge: 86400000
};

// Set cookie
res.cookie('authToken', token, cookieOptions);

// Clear cookie (exclude maxAge)
res.clearCookie('authToken', {
  ...cookieOptions
});




