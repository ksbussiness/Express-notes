Timers:
---------- >

.> The timer module exposes a global API for scheduling functions to be called at some future period of time. 
   Because the timer functions are globals, there is no need to call require('node:timers')/imports to use in the API.

Timers Promises API :
------------------------ >
..> The timers/promises API provides an alternative set of timer functions that return Promise objects. 
 # Note_point: signal <AbortSignal> An optional AbortSignal that can be used to cancel the scheduled Timeout.

EX:1
> timersPromises.setTimeout(delay, value);
The number of milliseconds to wait before fulfilling the promise

EX:2
> timersPromises.setImmediate(value);
A value with which the promise is fulfilled.


EX:3 
> timersPromises.setInterval(delay, value):
The number of milliseconds to wait between iterations



Cancelling Timers:
------------------------ >

Note :
.> The setImmediate(), setInterval(), and setTimeout() methods each return objects that represent the scheduled timers. 
.> These can be used to cancel the timer and prevent it from triggering.


clearImmediate(immediate) : Cancels an Immediate object created by setImmediate().
clearInterval(timeout) : Cancels a Timeout object created by setInterval().
clearTimeout(timeout) : Cancels a Timeout object created by setTimeout().


These timer cancelation is used for :

Very common use cases:
----------------------- >
cancel HTTP requests
stop long async tasks
cleanup when user leaves a page
prevent memory leaks

EX:-1
-------- >

const ac = new AbortController();
const signal = ac.signal;

fetch('/api/users', { signal })
  .then(res => res.json())
  .then(data => console.log(data))
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Fetch aborted');
    }
  });

// later
ac.abort(); //  cancels the request



| Timer                 | Used for             | Cancel function  |
| --------------------- | -------------------- | ---------------- |
| `setTimeout`          | Run once after delay | `clearTimeout`   |
| `setInterval`         | Run repeatedly       | `clearInterval`  |
| `setImmediate` (Node) | Run ASAP after I/O   | `clearImmediate` |



const ac = new AbortController();

const timeoutId = setTimeout(() => {
  ac.abort(); //  cancel fetch after 3s
}, 3000);

fetch('/api/data', { signal: ac.signal })
  .then(res => res.json())
  .then(data => {
    console.log('Response received', data);
  })
  .catch(err => {
    if (err.name === 'AbortError') {
      console.log('Request timed out');
    } else {
      console.error(err);
    }
  })
  .finally(() => {
    clearTimeout(timeoutId); //  stop timer if fetch finished
  });


Case 1️⃣ Response comes in 1.5s : In this case there will abort will not be called, here in this case. but the timer will be cleaned_up.
t = 0s   → fetch starts
t = 1.5s → response arrives
t = 1.5s → clearTimeout()
t = 3s   → abort never happens


Case 2️⃣ No response after 3s : In this case the abort will be called.
t = 0s   → fetch starts
t = 3s   → ac.abort() fires
t = 3s   → fetch rejects with AbortError
t = 3s+  → finally() clears timer.



PART_2 :-
================================================= >
















